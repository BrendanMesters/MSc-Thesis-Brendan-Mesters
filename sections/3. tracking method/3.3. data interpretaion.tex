\section{Data Interpretation}
\label{section: tracking method - data interpretation}

% \textbf{¡¡¡¡ The explanation is quite difficult to follow currently, think up specific terms and meanings, in order to make the explanation more clear!!!}\\
% Things to get a specific term for
% \begin{itemize}
    % \item MEB center
    % \item MEB radius
    % \item MEB circle (for reasoning)
    % \item specific arm zones, e.g. left low; left mid; left high; right low...
    % \item angle ranges
% \end{itemize}

The data interpretation is built upon the specific enhancements of the input data provided by the data enhancement method.
In our case, this entails a ball-shaped region that encloses the points of the user, the noise-signal labels, and the new point weight.
The data interpretation method will use this information to determine which position state the user is currently in.
\Cref{figure: internal data view} shows a visualization of the internal state of the system, with the ground truth in orange.


% The method used for data interpretation is tightly linked to the method used for data enhancement, since the data enhancement method adds a specific type of information to our input data.
% In the case of IAmMuse, we have the ball, which encompasses the user, as well as the extra dimension of weight, added to the point cloud.
% The data interpretation method of IAmMuse will thus be built around this new information.
% A visualization of this internal state, with the ground truth in orange, is shown in \cref{figure: internal data view - a}.

\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\linewidth]{figures/internal data/IAmMuse internal view.png}
        \caption{Internal data view}
        \label{figure: internal data view - a}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\linewidth]{figures/internal data/IAmMuse internal view with zones.png}
        \caption{Internal data view with zones}
        \label{figure: internal data view - b}
    \end{subfigure}
    
    \caption{Internal data view}
    \label{figure: internal data view}
\end{figure}


\subsection{Zone Prediciton}
We want to predict a specific zone, \textit{low}, \textit{middle}, or \textit{high}, for each hand.
These zones are represented to be the volume within a \textit{wedge}, as shown in \cref{figure: internal data view - b}. 
Note that there are two regions (top and bottom) that do not represent any zone.
Another equivalent way to specify a particular zone is as an angle range in the projection plane of the camera.
Each point can be assigned to a zone, using these angle ranges, and the angle of the vector going from the encompassing ball's center to the specific point.




\brendanLines
\input{sections/3. tracking method/3.3.1-2 conceptually and practically}
\subsection{Data Stabilization}
\label{sub-section: tracking method - data interpretation - data stabilization}

% stabilization intro & minimal points
There are a few issues with the current system, though, all to do with the stability of the resulting prediction, and extra systems have been put in place to mitigate these issues.
Firstly, one issue occurs because the mmWave radar occasionally produces very sparse frames. 
Sparse frames contain disproportionately few points, and thus also contain disproportionately few signal points. 
This means that the predictions of IAmMuse are more susceptible to the random variations in the point distributions, as well as being more susceptible to noise, since the prediction system simply looks at which zone has the highest weight.
The way in which IAmMuse mitigates this issue is by setting a \textit{minimal weight} which a zone must have to be considered as a "valid prediction". 
If no valid prediction was made for a side, the previous prediction is kept.
This mitigation strategy does have the side effect of ignoring some frames if they are too sparse, but this isn't a huge problem, as the amount of information present in that frame was already very low because of how sparse it was.
A solution that adds the data from these "missed frames" to the following frames could be made.
This would increase the amount of information the system uses, but could also induce a lower responsiveness by taking into account stale information.
For these reasons, such a system was not put in place in IAmMuse.


% Multiple predictions needed
Another similar issue occurs when a large spike of noise is perceived for a single frame, this influx of faulty data can make the system select an incorrect zone.
These large noise spikes do not happen regularly, but they happen often enough that a mitigation system is needed.
In these cases, most frames in a sequence will give a similar result, but one frame will give a "faulty prediction".
Since we know that, in a correctly predicted set of frames, the same zone is likely to be predicted multiple times in a row, as the user's arm stays in that zone, we can filter out the faulty case by only choosing a new zone if that zone has been predicted twice in a row.
In this system, it's important not to count "missing predictions" (as specified in the previous paragraph) as a part of these consecutive predictions.
This system does add some delay to the selection of a new zone, specifically 100ms if you receive correct predictions every frame. 
For the IAmMuse system, this delay is a worthwhile tradeoff for the added stability against both noise and random fluctuations in the mmWave radars' output, but this may not be the case for every system.

% Zone expansion
Lastly, in the scenario where a user is holding their arm near the border of two zones, an issue occurred where, for each frame, either zone could be predicted at random, due to the inherent random distribution in the mmWave point clouds.
% Lastly, IAmMuse had to solve an issue in the scenario where a user is holding their arm near the border of two zones.
% In this case, IAmMuse may predict either zone at random, purely due to the random nature in which the points in a mmWave frame are distributed.
While a singular frame prediction would not be incorrect per se, the fact that the system produces an unstable output while the user provides a stable input (a stationary arm) is incorrect.
The way that IAmMuse solves this issue is by expanding the range of angles associated with the currently selected zone.
This eliminates the issue, as the randomly distributed points that are on the edge of the two zones will be predominantly in the active zone if the zone's angle range is increased.
In IAmMuse, the active zone's angle range is increased by $10\degree$, or $5\degree$ on each side, and neighboring zones are shrunk in accordance.
This increase should be as small as possible while still providing the stability-increasing effect.
During system design, an increase of $10\degree$ seemed to be the smallest amount that fulfilled this wish.





% The data interpretation method is often tightly linked to the data enhancement method used, as we will use the extra context provided by the data enhancement in the interpretation.
% In the case of IAmMuse's final system, the extra context we've been given is the MEB, providing us with a rough center point of the user, as well as an estimation of the outer reach of their arms.
% % simplify to 2d explained
% During the design and explanation of the interpretation algorithm, we will often simplify the user's points to be on a plane, rather than in 3d space. 
% The MEB would then likewise be considered to be a circle, with the center still at the user's sternum, and the edge tracing the path the user's hands can trace (assuming outstretched arms).
% This estimation makes the reasoning a lot more intuitive. At the end of the section, we will also briefly touch on why this reasoning also extends to our actual system, which does operate in 3d space, rather than 2d space.
% % continue
% The main idea which is used in the interpretation of the data is that the angle of the arm is very closely modeled by looking at the angle between the sternum and a user's hand.
% The sternum position is already known to be roughly at the center of the MEB, and the user's hands are known to be roughly at the edge of the MEB circle.
% This transforms our problem of "find the angle of the arms" to "find the position of the hands on our circle", which turns out to be a lot simpler.
% 
% To find the angle of the arms, a few things need to be done: points that belong to the hand should be specified, these points should be placed on the MEB circle, the angles between these points and the MEB center should be calculated, and this set of angles should be transformed into a hand/arm angle prediction.
% The first step is done in a somewhat different way. 
% We know that the points at the circle edge tell us a lot of things about the position of the hands, and the further away a point is from that circle edge, the less we trust the information. 
% Since your arm position tells you something of where the hand is, but your torso won't tell you anything.
% For this reason, each point is given a \textit{weight}, dependent on its distance to the circle edge.
% In practice, this is achieved by taking the distance between a point and the MEB center, and applying the Gaussian function to this distance, where $\mu$ is the radius of the MEB, $\sigma^2$ is taken to be $0.25$, and x is the previously mentioned distance.
% The output of this function is used as a weight of the point, which is representative of "how hand-like" the point is.
% Calculating the angle for each point is a trivial trigonometric function, and will leave us with a set of angles with weights.
% 
% The last part of the interpretation is turning this list of angels and weights into two final arm positions, one for the right arm and one for the left arm.
% In this thesis, we do not care about the exact arm position, rather, we care about the "region" where the arm currently is.
% This region is specified as being "low", "middle", or "high", which are simply ranges of angles in which the arm can be.
% The fact that the system is expected to generate an output region can be used in the interpretation.
% To find out the likelihood of an arm being present in a specific region, you can look at the "weight" of said region, where a region's weight is the sum of the weights of all points (angles) that exist in that region.
% In this manner, a frame-specific prediction for the arm location can be generated by selecting the zone with the highest weight on each side (left, right).
% One problem with this approach is that the output is very unstable.
% 
% A few methods are used to stabilize the output of the arm location predictions.\\
% Firstly, the arm position (low, mid, high) that is currently selected will increase the angle range that it considers "its region" by $5\degree$ on each side. 
% e.g. the middle zone usually considers points "in its zone" when their angle is between $65\degree$ and $105\degree$, but if the middle zone is already selected, it will now consider angles between $60\degree$ and $110\degree$, this region increase will shrink the other regions.
% This system avoids the situations where a user's arm is "on the edge" of two zones and rapidly changes which zone is predicted while the user keeps their arm still.\\
% Secondly, there is a certain threshold weight that a zone needs to achieve to be considered as a "valid zone contender", this makes sure that very sparse frames can not trigger a faulty zone change based on only a few points.\\
% Lastly, a specific zone is only selected as the actual zone if it was predicted to be the correct zone twice in a row.
% Note that some frames may not have any predictions at all if none of the zones crossed the weight threshold, in this case, no prediction was made, thus it does not impede a zone from being chosen twice.
% e.g. \textit{frame n}, zone left low is selected. \textit{frame n+1} no zone is selected. \textit{frame n + 2} zone left low is selected.
% In this situation, \textit{left low} has been selected twice in a row, thus, the zone gets set to left low.
% 
% Earlier in the section, it was stated that we could reason about the minimal enclosing ball as if it were a circle, the reasons for this assumption will be given here.
% First off, during the usage of the system, the user is expected to stand facing the FMCW, with their arms out to the side, lifting or lowering them.
% In this situation, the point cloud produced by the user falls roughly in a plane where we simply ignore the y direction, thus, for the points belonging to the user, the simplification to a circle is valid.
% Furthermore, the number of noise points that still exist in this part of the pipeline is small, and given the spatial distribution observed from these points, the likelihood of one of these points being present near the edge of the ball but in front of or behind the user is very slim.
% Therefore, only outlier points will ever appear near the edge of the ball while not being well modeled by the circle.
% Points that are at a large distance from the edge of the ball will be disregarded automatically by being assigned a low weight, as the distance between the centroid and the specific point can be (and is) calculated in 3d.
% Due to the above given reasons, there is no feasible situation in which the assumption (for reasoning purposes) of a circle does not apply accurately to our actual ball.
% Lastly, it's important to mention how we get the "angle" between two points now, given that we are not actually using 2d coordinates in the system.
% The angle of the arm is considered to be the angle between the down vector and the vector that goes from the MEB circle to the point in question.
% This has the added benefit that users are allowed to hold their arms at a somewhat forward angle if this is more comfortable for them, and the calculation still holds true in the same manner.



% % This section describes HOW we do the data interpretation, given the different systems described above, specifically the minimal enclosing ball.
% % This includes the general high-level overview of the system, including zones on the MEB, filtering, and processing.
% % It will also discuss different smaller systems, such as the active zone size increasing code, the stabilization code, which requires a zone to be selected more often, and will discuss the concept of "weight" in the various system contexts.
% % 
% % \textbf{We use a ball, not a circle, explain}